{"version":3,"file":"vue-mention.min.js","sources":["../../../node_modules/textarea-caret/index.js","../src/Mentionable.vue","../src/index.js"],"sourcesContent":["/* jshint browser: true */\n\n(function () {\n\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nvar properties = [\n  'direction',  // RTL support\n  'boxSizing',\n  'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY',  // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration',  // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize'\n\n];\n\nvar isBrowser = (typeof window !== 'undefined');\nvar isFirefox = (isBrowser && window.mozInnerScreenX != null);\n\nfunction getCaretCoordinates(element, position, options) {\n  if (!isBrowser) {\n    throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');\n  }\n\n  var debug = options && options.debug || false;\n  if (debug) {\n    var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n    if (el) el.parentNode.removeChild(el);\n  }\n\n  // The mirror div will replicate the textarea's style\n  var div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  var style = div.style;\n  var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9\n  var isInput = element.nodeName === 'INPUT';\n\n  // Default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (!isInput)\n    style.wordWrap = 'break-word';  // only for textarea-s\n\n  // Position off-screen\n  style.position = 'absolute';  // required to return coordinates properly\n  if (!debug)\n    style.visibility = 'hidden';  // not 'display: none' because we want rendering\n\n  // Transfer the element's properties to the div\n  properties.forEach(function (prop) {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      style.lineHeight = computed.height;\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > parseInt(computed.height))\n      style.overflowY = 'scroll';\n  } else {\n    style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, position);\n  // The second special handling for input type=\"text\" vs textarea:\n  // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n  if (isInput)\n    div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n\n  var span = document.createElement('span');\n  // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textarea's content into the <span> created at the caret position.\n  // For inputs, just '.' would be enough, but no need to bother.\n  span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all\n  div.appendChild(span);\n\n  var coordinates = {\n    top: span.offsetTop + parseInt(computed['borderTopWidth']),\n    left: span.offsetLeft + parseInt(computed['borderLeftWidth']),\n    height: parseInt(computed['lineHeight'])\n  };\n\n  if (debug) {\n    span.style.backgroundColor = '#aaa';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nif (typeof module != 'undefined' && typeof module.exports != 'undefined') {\n  module.exports = getCaretCoordinates;\n} else if(isBrowser) {\n  window.getCaretCoordinates = getCaretCoordinates;\n}\n\n}());\n","<script>\nimport getCaretPosition from 'textarea-caret'\nimport { Dropdown, options } from 'floating-vue'\n\noptions.themes.mentionable = {\n  $extend: 'dropdown',\n  placement: 'top-start',\n  arrowPadding: 6,\n  arrowOverflow: false,\n}\n\nconst userAgent = typeof window !== 'undefined' ? window.navigator.userAgent : ''\nconst isIe = userAgent.indexOf('MSIE ') !== -1 || userAgent.indexOf('Trident/') !== -1\n\nexport default {\n  components: {\n    VDropdown: Dropdown,\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    keys: {\n      type: Array,\n      required: true,\n    },\n\n    placement: {\n      type: String,\n      default: 'top-start',\n    },\n\n    items: {\n      type: Array,\n      default: () => [],\n    },\n\n    omitKey: {\n      type: Boolean,\n      default: false,\n    },\n\n    filteringDisabled: {\n      type: Boolean,\n      default: false,\n    },\n\n    insertSpace: {\n      type: Boolean,\n      default: false,\n    },\n\n    mapInsert: {\n      type: Function,\n      default: null,\n    },\n\n    limit: {\n      type: Number,\n      default: 8,\n    },\n\n    theme: {\n      type: String,\n      default: 'mentionable',\n    },\n\n    caretHeight: {\n      type: Number,\n      default: 0,\n    },\n\n    hideNoResult: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  data () {\n    return {\n      key: null,\n      oldKey: null,\n      searchText: null,\n      caretPosition: null,\n      selectedIndex: 0,\n    }\n  },\n\n  computed: {\n    filteredItems () {\n      if (!this.searchText || this.filteringDisabled) {\n        return this.items\n      }\n\n      const searchText = this.searchText.toLowerCase()\n\n      return this.items.filter(item => {\n        /** @type {string} */\n        let text\n        if (item.searchText) {\n          text = item.searchText\n        } else if (item.label) {\n          text = item.label\n        } else {\n          text = ''\n          for (const key in item) {\n            text += item[key]\n          }\n        }\n        return text.toLowerCase().includes(searchText)\n      })\n    },\n\n    displayedItems () {\n      return this.filteredItems.slice(0, this.limit)\n    },\n  },\n\n  watch: {\n    displayedItems () {\n      this.selectedIndex = 0\n    },\n\n    searchText (value, oldValue) {\n      if (value) {\n        this.$emit('search', value, oldValue)\n      }\n    },\n  },\n\n  mounted () {\n    this.input = this.getInput()\n    this.attach()\n  },\n\n  updated () {\n    const input = this.getInput()\n    if (input !== this.input) {\n      this.detach()\n      this.input = input\n      this.attach()\n    }\n  },\n\n  beforeDestroy () {\n    this.detach()\n  },\n\n  methods: {\n    getInput () {\n      const [vnode] = this.$scopedSlots.default()\n      if (vnode) {\n        if (vnode.elm.tagName === 'INPUT' || vnode.elm.tagName === 'TEXTAREA' || vnode.elm.isContentEditable) {\n          return vnode.elm\n        } else {\n          return vnode.elm.querySelector('input') || vnode.elm.querySelector('textarea') || vnode.elm.querySelector('[contenteditable=\"true\"]')\n        }\n      }\n      return null\n    },\n\n    attach () {\n      if (this.input) {\n        this.input.addEventListener('input', this.onInput)\n        this.input.addEventListener('keydown', this.onKeyDown)\n        this.input.addEventListener('keyup', this.onKeyUp)\n        this.input.addEventListener('scroll', this.onScroll)\n        this.input.addEventListener('blur', this.onBlur)\n      }\n    },\n\n    detach () {\n      if (this.input) {\n        this.input.removeEventListener('input', this.onInput)\n        this.input.removeEventListener('keydown', this.onKeyDown)\n        this.input.removeEventListener('keyup', this.onKeyUp)\n        this.input.removeEventListener('scroll', this.onScroll)\n        this.input.removeEventListener('blur', this.onBlur)\n      }\n    },\n\n    onInput () {\n      this.checkKey()\n    },\n\n    onBlur () {\n      this.closeMenu()\n    },\n\n    onKeyDown (e) {\n      if (this.key) {\n        if (e.key === 'ArrowDown' || e.keyCode === 40) {\n          this.selectedIndex++\n          if (this.selectedIndex >= this.displayedItems.length) {\n            this.selectedIndex = 0\n          }\n          this.cancelEvent(e)\n        }\n        if (e.key === 'ArrowUp' || e.keyCode === 38) {\n          this.selectedIndex--\n          if (this.selectedIndex < 0) {\n            this.selectedIndex = this.displayedItems.length - 1\n          }\n          this.cancelEvent(e)\n        }\n        if ((e.key === 'Enter' || e.key === 'Tab' || e.keyCode === 13 || e.keyCode === 9) &&\n          this.displayedItems.length > 0) {\n          this.applyMention(this.selectedIndex)\n          this.cancelEvent(e)\n        }\n        if (e.key === 'Escape' || e.keyCode === 27) {\n          this.closeMenu()\n          this.cancelEvent(e)\n        }\n      }\n    },\n\n    onKeyUp (e) {\n      if (this.cancelKeyUp && (e.key === this.cancelKeyUp || e.keyCode === this.cancelKeyCode)) {\n        this.cancelEvent(e)\n      }\n      this.cancelKeyUp = null\n      // IE\n      this.cancelKeyCode = null\n    },\n\n    cancelEvent (e) {\n      e.preventDefault()\n      e.stopPropagation()\n      this.cancelKeyUp = e.key\n      // IE\n      this.cancelKeyCode = e.keyCode\n    },\n\n    onScroll () {\n      this.updateCaretPosition()\n    },\n\n    getSelectionStart () {\n      return this.input.isContentEditable ? window.getSelection().anchorOffset : this.input.selectionStart\n    },\n\n    setCaretPosition (index) {\n      this.$nextTick(() => {\n        this.input.selectionEnd = index\n      })\n    },\n\n    getValue () {\n      if (this.input.isContentEditable) {\n        const node = window.getSelection().anchorNode\n        if (!node.children) {\n          return node.textContent\n        }\n        return ''\n      }\n      return this.input.value\n    },\n\n    setValue (value) {\n      this.input.value = value\n      this.emitInputEvent('input')\n    },\n\n    emitInputEvent (type) {\n      let event\n      if (isIe) {\n        event = document.createEvent('Event')\n        event.initEvent(type, true, true)\n      } else {\n        event = new Event(type)\n      }\n      this.input.dispatchEvent(event)\n    },\n\n    checkKey () {\n      const index = this.getSelectionStart()\n      if (index >= 0) {\n        const { key, keyIndex } = this.getLastKeyBeforeCaret(index)\n        const searchText = this.lastSearchText = this.getLastSearchText(index, keyIndex)\n        if (!(keyIndex < 1 || /\\s/.test(this.getValue()[keyIndex - 1]))) {\n          return false\n        }\n        if (searchText != null) {\n          this.openMenu(key, keyIndex)\n          this.searchText = searchText\n          return true\n        }\n      }\n      this.closeMenu()\n      return false\n    },\n\n    getLastKeyBeforeCaret (caretIndex) {\n      const [keyData] = this.keys.map(key => ({\n        key,\n        keyIndex: this.getValue().lastIndexOf(key, caretIndex - 1),\n      })).sort((a, b) => b.keyIndex - a.keyIndex)\n      return keyData\n    },\n\n    getLastSearchText (caretIndex, keyIndex) {\n      if (keyIndex !== -1) {\n        const searchText = this.getValue().substring(keyIndex + 1, caretIndex)\n        // If there is a space we close the menu\n        if (!/\\s/.test(searchText)) {\n          return searchText\n        }\n      }\n      return null\n    },\n\n    openMenu (key, keyIndex) {\n      if (this.key !== key) {\n        this.key = key\n        this.keyIndex = keyIndex\n        this.updateCaretPosition()\n        this.selectedIndex = 0\n        this.$emit('open', key)\n      }\n    },\n\n    closeMenu () {\n      if (this.key != null) {\n        this.oldKey = this.key\n        this.key = null\n        this.$emit('close', this.oldKey)\n      }\n    },\n\n    updateCaretPosition () {\n      if (this.key) {\n        if (this.input.isContentEditable) {\n          const rect = window.getSelection().getRangeAt(0).getBoundingClientRect()\n          const inputRect = this.input.getBoundingClientRect()\n          this.caretPosition = {\n            left: rect.left - inputRect.left,\n            top: rect.top - inputRect.top,\n            height: rect.height,\n          }\n        } else {\n          this.caretPosition = getCaretPosition(this.input, this.keyIndex)\n        }\n        this.caretPosition.top -= this.input.scrollTop\n        if (this.caretHeight) {\n          this.caretPosition.height = this.caretHeight\n        } else if (isNaN(this.caretPosition.height)) {\n          this.caretPosition.height = 16\n        }\n      }\n    },\n\n    applyMention (itemIndex) {\n      const item = this.displayedItems[itemIndex]\n      const value = (this.omitKey ? '' : this.key) + String(this.mapInsert ? this.mapInsert(item, this.key) : item.value) + (this.insertSpace ? ' ' : '')\n      if (this.input.isContentEditable) {\n        const range = window.getSelection().getRangeAt(0)\n        range.setStart(range.startContainer, range.startOffset - this.key.length - (this.lastSearchText ? this.lastSearchText.length : 0))\n        range.deleteContents()\n        range.insertNode(document.createTextNode(value))\n        range.setStart(range.endContainer, range.endOffset)\n        this.emitInputEvent('input')\n      } else {\n        this.setValue(this.replaceText(this.getValue(), this.searchText, value, this.keyIndex))\n        this.setCaretPosition(this.keyIndex + value.length)\n      }\n      this.$emit('apply', item, this.key, value)\n      this.closeMenu()\n    },\n\n    replaceText (text, searchText, newText, index) {\n      return text.slice(0, index) + newText + text.slice(index + searchText.length + 1, text.length)\n    },\n  },\n}\n</script>\n\n<template>\n  <div\n    class=\"mentionable\"\n    style=\"position:relative;\"\n  >\n    <slot />\n\n    <VDropdown\n      ref=\"popper\"\n      v-bind=\"$attrs\"\n      :placement=\"placement\"\n      :shown=\"!!key\"\n      :triggers=\"[]\"\n      :auto-hide=\"false\"\n      :theme=\"theme\"\n      class=\"popper\"\n      style=\"position:absolute;\"\n      :style=\"caretPosition ? {\n        top: `${caretPosition.top}px`,\n        left: `${caretPosition.left}px`,\n      } : {}\"\n    >\n      <div\n        :style=\"caretPosition ? {\n          height: `${caretPosition.height}px`,\n        } : {}\"\n      />\n\n      <template #popper>\n        <div v-if=\"!displayedItems.length && !hideNoResult\">\n          <slot name=\"no-result\">\n            No result\n          </slot>\n        </div>\n\n        <template v-else-if=\"displayedItems.length > 0\">\n          <div\n            v-for=\"(item, index) of displayedItems\"\n            :key=\"index\"\n            class=\"mention-item\"\n            :class=\"{\n              'mention-selected': selectedIndex === index,\n            }\"\n            @mouseover=\"selectedIndex = index\"\n            @mousedown=\"applyMention(index)\"\n          >\n            <slot\n              :name=\"`item-${key || oldKey}`\"\n              :item=\"item\"\n              :index=\"index\"\n            >\n              <slot\n                name=\"item\"\n                :item=\"item\"\n                :index=\"index\"\n              >\n                {{ item.label || item.value }}\n              </slot>\n            </slot>\n          </div>\n        </template>\n      </template>\n    </VDropdown>\n  </div>\n</template>\n","import Mentionable from './Mentionable.vue'\r\n\r\nexport {\r\n  Mentionable,\r\n}\r\n\r\nfunction registerComponents (Vue, prefix) {\r\n  Vue.component(`${prefix}mentionable`, Mentionable)\r\n  Vue.component(`${prefix}Mentionable`, Mentionable)\r\n}\r\n\r\nconst plugin = {\r\n  // eslint-disable-next-line no-undef\r\n  version: VERSION,\r\n  install (Vue, options) {\r\n    const finalOptions = Object.assign({}, {\r\n      installComponents: true,\r\n      componentsPrefix: '',\r\n    }, options)\r\n\r\n    if (finalOptions.installComponents) {\r\n      registerComponents(Vue, finalOptions.componentsPrefix)\r\n    }\r\n  },\r\n}\r\n\r\nexport default plugin\r\n\r\n// Auto-install\r\nlet GlobalVue = null\r\nif (typeof window !== 'undefined') {\r\n  GlobalVue = window.Vue\r\n} else if (typeof global !== 'undefined') {\r\n  GlobalVue = global.Vue\r\n}\r\nif (GlobalVue) {\r\n  GlobalVue.use(plugin)\r\n}\r\n"],"names":["properties","isBrowser","isFirefox","window","mozInnerScreenX","module","element","position","options","Error","debug","el","document","querySelector","parentNode","removeChild","div","createElement","id","body","appendChild","style","computed","getComputedStyle","currentStyle","isInput","nodeName","whiteSpace","wordWrap","visibility","forEach","prop","lineHeight","height","scrollHeight","parseInt","overflowY","overflow","textContent","value","substring","replace","span","coordinates","top","offsetTop","left","offsetLeft","backgroundColor","plugin","version","VERSION","install","Vue","finalOptions","Object","assign","installComponents","componentsPrefix","prefix","component","Mentionable","registerComponents","GlobalVue","global","use"],"mappings":"gkCAEC,IAMGA,EA0CAC,EACAC,EA3CAF,EAAa,CACf,wBAEA,iBAEA,YACA,6BAGA,mBACA,oBACA,kBACA,cAEA,aACA,eACA,gBACA,0BAIA,cACA,aACA,cACA,WACA,iBACA,aACA,aAEA,YACA,gBACA,aACA,iCAGA,cAEA,UACA,cAIEC,EAA+B,oBAAXE,OACpBD,EAAaD,GAAuC,MAA1BE,OAAOC,gBAiFnCC,mBA/E2BC,EAASC,EAAUC,OACzCP,QACG,IAAIQ,MAAM,sFAGdC,EAAQF,GAAWA,EAAQE,QAAS,KACpCA,EAAO,KACLC,EAAKC,SAASC,cAAc,6CAC5BF,GAAIA,EAAGG,WAAWC,YAAYJ,OAIhCK,EAAMJ,SAASK,cAAc,OACjCD,EAAIE,GAAK,2CACTN,SAASO,KAAKC,YAAYJ,OAEtBK,EAAQL,EAAIK,MACZC,EAAWnB,OAAOoB,iBAAmBpB,OAAOoB,iBAAiBjB,GAAWA,EAAQkB,aAChFC,EAA+B,UAArBnB,EAAQoB,SAGtBL,EAAMM,WAAa,WACdF,IACHJ,EAAMO,SAAW,cAGnBP,EAAMd,SAAW,WACZG,IACHW,EAAMQ,WAAa,UAGrB7B,EAAW8B,SAAQ,SAAUC,GACvBN,GAAoB,eAATM,EAEbV,EAAMW,WAAaV,EAASW,OAE5BZ,EAAMU,GAAQT,EAASS,MAIvB7B,EAEEI,EAAQ4B,aAAeC,SAASb,EAASW,UAC3CZ,EAAMe,UAAY,UAEpBf,EAAMgB,SAAW,SAGnBrB,EAAIsB,YAAchC,EAAQiC,MAAMC,UAAU,EAAGjC,GAGzCkB,IACFT,EAAIsB,YAActB,EAAIsB,YAAYG,QAAQ,MAAO,UAE/CC,EAAO9B,SAASK,cAAc,QAMlCyB,EAAKJ,YAAchC,EAAQiC,MAAMC,UAAUjC,IAAa,IACxDS,EAAII,YAAYsB,OAEZC,EAAc,CAChBC,IAAKF,EAAKG,UAAYV,SAASb,EAAQ,gBACvCwB,KAAMJ,EAAKK,WAAaZ,SAASb,EAAQ,iBACzCW,OAAQE,SAASb,EAAQ,oBAGvBZ,EACFgC,EAAKrB,MAAM2B,gBAAkB,OAE7BpC,SAASO,KAAKJ,YAAYC,GAGrB2B,8GCrHT,otPCAMM,EAAS,CAEbC,QAASC,sBACTC,iBAASC,EAAK7C,OACN8C,EAAeC,OAAOC,OAAO,GAAI,CACrCC,mBAAmB,EACnBC,iBAAkB,IACjBlD,GAEC8C,EAAaG,mBAdrB,SAA6BJ,EAAKM,GAChCN,EAAIO,oBAAaD,iBAAqBE,GACtCR,EAAIO,oBAAaD,iBAAqBE,GAalCC,CAAmBT,EAAKC,EAAaI,oBAQvCK,EAAY,WACM,oBAAX5D,OACT4D,EAAY5D,OAAOkD,IACQ,oBAAXW,SAChBD,EAAYC,OAAOX,KAEjBU,GACFA,EAAUE,IAAIhB"}